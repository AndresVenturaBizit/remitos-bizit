import io
import json
import re
import urllib.parse

from odoo.addons.web.controllers import report
from odoo.http import request, route
from PyPDF2 import PdfFileReader


class ReportController(report.ReportController):
    def _count_pages_with_products(self, pdf_reader, picking_id):
        """
        Cuenta las páginas que realmente contienen productos
        analizando el contenido de texto de cada página
        """
        picking = request.env["stock.picking"].browse(picking_id)
        move_lines = picking.move_line_ids

        # Si no hay move_lines, usar move_ids como fallback
        if not move_lines:
            move_lines = picking.move_ids

        product_codes = [line.product_id.default_code or line.product_id.name for line in move_lines if line.product_id]

        pages_with_products = 0

        for page_num in range(len(pdf_reader.pages)):
            try:
                page = pdf_reader.pages[page_num]
                text = page.extract_text()

                # Verificar si algún código/nombre de producto aparece en esta página
                has_products = any(
                    product_code and product_code in text for product_code in product_codes if product_code
                )

                if has_products:
                    pages_with_products += 1

            except Exception:
                # Si hay error extrayendo texto, asumimos que tiene productos
                pages_with_products += 1

        # Asegurar que al menos hay 1 página con productos
        return max(1, pages_with_products)

    @route()
    def report_download(self, data, context=None):
        """This function is used by 'qwebactionmanager.js' in order to trigger
        the download of a py3o/controller report.
        :param data: a javascript array JSON.stringified containg report
        internal url ([0]) and type [1]
        :returns: Response with a filetoken cookie and an attachment header
        """
        response = super().report_download(data, context)
        # NTH detect if the binary is a PDF, no matter ifn it was generated by a QWeb or Aeroo
        requestcontent = json.loads(data)
        url, type = requestcontent[0], requestcontent[1]
        if type == "aeroo" and "remito" in url:
            context_part = json.loads(data)[0].split("context=")[1]
            context_dict = json.loads(urllib.parse.unquote(context_part))
            picking_id = context_dict.get("active_ids")
            assign = context_dict.get("assign")
            book_id = request.env["stock.picking"].browse(picking_id).book_id
            if assign and book_id and picking_id:
                copies_result = request.env["ir.actions.report"].search_read(
                    [("report_name", "ilike", "remito")], ["copies"], limit=1
                )
                copies = copies_result[0]["copies"] if copies_result else None
                pdf_response = response.response[0]
                reader = PdfFileReader(io.BytesIO(pdf_response))

                # Usar el nuevo método para contar páginas con productos
                if copies:
                    total_pages = int(len(reader.pages) / copies)
                    number_pages = self._count_pages_with_products(reader, picking_id)
                    # Ajustar por número de copias
                    number_pages = min(number_pages, total_pages)
                else:
                    number_pages = self._count_pages_with_products(reader, picking_id)

                # See if there are vouchers already assigned. If not, then it assigns the vouchers
                if not request.env["stock.picking"].browse(picking_id).voucher_ids and book_id:
                    request.env["stock.picking"].browse(picking_id).assign_numbers(number_pages, book_id)

        elif "report_deliveryslip" in url:
            # If the report is not an aeroo, the assign method should only assign one voucher
            match = re.search(r"(\d+)$", json.loads(data)[0])
            if match:
                picking_id = int(match.group(1))
                book_id = request.env["stock.picking"].browse(picking_id).book_id
                if book_id and book_id.autoprinted == False and picking_id:
                    pdf_response = response.response[0]
                    reader = PdfFileReader(io.BytesIO(pdf_response))

                    # Usar el nuevo método para contar páginas con productos
                    copies_result = request.env["ir.actions.report"].search_read(
                        [("report_name", "=", "stock.report_deliveryslip")], ["l10n_ar_copies"], limit=1
                    )
                    copies = copies_result[0]["l10n_ar_copies"] if copies_result else None

                    if copies == "triplicado":
                        total_pages = int(len(reader.pages) / 3)
                    elif copies == "duplicado":
                        total_pages = int(len(reader.pages) / 2)
                    else:
                        total_pages = len(reader.pages)

                    number_pages = self._count_pages_with_products(reader, picking_id)
                    number_pages = min(number_pages, total_pages)

                    if not request.env["stock.picking"].browse(picking_id).voucher_ids and book_id:
                        request.env["stock.picking"].browse(picking_id).assign_numbers(number_pages, book_id)

                elif book_id and picking_id:
                    if not request.env["stock.picking"].browse(picking_id).voucher_ids and book_id:
                        request.env["stock.picking"].browse(picking_id).assign_numbers(1, book_id)

        return response
